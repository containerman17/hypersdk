<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script src="https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/cdn/metamask-sdk.js"></script>
    <script>
        const sdk = new MetaMaskSDK.MetaMaskSDK({
            dappMetadata: {
                name: "Pure JS example",
                url: window.location.host,
            },
            logging: {
                sdk: false,
            }
        });
    </script>
    <script>
        let provider;

        function connect() {
            return sdk.connect()
                .then((res) => {
                    provider = sdk.getProvider();
                })
                .catch((e) => console.log('request accounts ERR', e));
        }

        function addEthereumChain() {
            provider
                .request({
                    method: 'wallet_addEthereumChain',
                    params: [
                        {
                            chainId: '0x89',
                            chainName: 'Polygon',
                            blockExplorerUrls: ['https://polygonscan.com'],
                            nativeCurrency: { symbol: 'MATIC', decimals: 18 },
                            rpcUrls: ['https://polygon-rpc.com/'],
                        },
                    ],
                })
                .then((res) => console.log('add', res))
                .catch((e) => console.log('ADD ERR', e));
        }

        async function signText() {
            await connect();
            const exampleMessage = "Example `personal_sign` message.";
            try {
                const accounts = await provider.request({ method: 'eth_requestAccounts' });
                const from = accounts[0];
                // For historical reasons, you must submit the message to sign in hex-encoded UTF-8.
                // This uses a Node.js-style buffer shim in the browser.
                const msg = "Example `personal_sign` message";
                const sign = await ethereum.request({
                    method: "personal_sign",
                    params: [msg, from],
                });
                console.log(sign)
            } catch (err) {
                console.error(err);
            }
        }

        async function signStructuredExample() {
            // eth_signTypedData_v4 parameters. All of these parameters affect the resulting signature.
            const msgParams = JSON.stringify({
                domain: {
                    // This defines the network, in this case, Mainnet.
                    chainId: 1,
                    // Give a user-friendly name to the specific contract you're signing for.
                    name: "Ether Mail",
                    // Add a verifying contract to make sure you're establishing contracts with the proper entity.
                    verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
                    // This identifies the latest version.
                    version: "1",
                },

                // This defines the message you're proposing the user to sign, is dapp-specific, and contains
                // anything you want. There are no required fields. Be as explicit as possible when building out
                // the message schema.
                message: {
                    contents: 'Hello, Bob!',
                    from: {
                        name: 'Cow',
                        wallets: [
                            '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
                            '0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF',
                        ],
                    },
                    to: [
                        {
                            name: 'Bob',
                            wallets: [
                                '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
                                '0xB0BdaBea57B0BDABeA57b0bdABEA57b0BDabEa57',
                                '0xB0B0b0b0b0b0B000000000000000000000000000',
                            ],
                        },
                    ],
                    attachment: '0x',
                },
                // This refers to the keys of the following types object.
                primaryType: "Mail",
                types: {
                    EIP712Domain: [
                        { name: 'name', type: 'string' },
                        { name: 'version', type: 'string' },
                        { name: 'chainId', type: 'uint256' },
                        { name: 'verifyingContract', type: 'address' },
                    ],
                    Group: [
                        { name: 'name', type: 'string' },
                        { name: 'members', type: 'Person[]' },
                    ],
                    Mail: [
                        { name: 'from', type: 'Person' },
                        { name: 'to', type: 'Person[]' },
                        { name: 'contents', type: 'string' },
                        { name: 'attachment', type: 'bytes' },
                    ],
                    Person: [
                        { name: 'name', type: 'string' },
                        { name: 'wallets', type: 'address[]' },
                    ],
                },
            });

            await connect();

            const accounts = await provider.request({ method: 'eth_requestAccounts' });

            var params = [accounts[0], msgParams];
            var method = "eth_signTypedData_v4";
            console.log("Using account: ", accounts[0])

            await provider // Or window.ethereum if you don't support EIP-6963.
                .sendAsync(
                    {
                        method,
                        params,
                        from: accounts[0],
                    },
                    function (err, result) {
                        if (err) return console.dir(err);
                        if (result.error) {
                            alert(result.error.message);
                        }
                        if (result.error) return console.error("ERROR", result);
                        console.log("TYPED SIGNED:" + JSON.stringify(result.result));


                    }
                );
        }

        async function signStructuredTailored() {
            await connect();


            const chainId = await provider.request({ method: 'eth_chainId' });
            // eth_signTypedData_v4 parameters. All of these parameters affect the resulting signature.
            const msgParams = JSON.stringify({
                domain: {
                    // This defines the network, in this case, Mainnet.
                    chainId: chainId,
                    // Give a user-friendly name to the specific contract you're signing for.
                    name: "MySubnet",
                    // Add a verifying contract to make sure you're establishing contracts with the proper entity.
                    verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
                    // This identifies the latest version.
                    version: "1",
                },

                // This defines the message you're proposing the user to sign, is dapp-specific, and contains
                // anything you want. There are no required fields. Be as explicit as possible when building out
                // the message schema.
                message: {
                    expiration: new Date(Date.now() + 10 * 60 * 1000).toISOString(),
                    maxFee: '123.02',
                    transfer:
                    {
                        to: '0xc0dec0dec0dec0dec0dec0dec0dec0dec0dec0de',
                        amount: '1234.56',
                    },

                },
                // This refers to the keys of the following types object.
                primaryType: "Transaction",
                types: {
                    EIP712Domain: [
                        { name: 'name', type: 'string' },
                        { name: 'version', type: 'string' },
                        { name: 'chainId', type: 'uint256' },
                        { name: 'verifyingContract', type: 'address' },
                    ],
                    Transaction: [
                        { name: 'expiration', type: 'string' },
                        { name: 'maxFee', type: 'string' },
                        { name: 'transfer', type: 'Transfer' },
                    ],
                    Transfer: [
                        { name: 'to', type: 'address' },
                        { name: 'amount', type: 'string' },
                    ],
                },
            });


            const accounts = await provider.request({ method: 'eth_requestAccounts' });

            var params = [accounts[0], msgParams];
            var method = "eth_signTypedData_v4";
            console.log("Using account: ", accounts[0])

            await provider // Or window.ethereum if you don't support EIP-6963.
                .sendAsync(
                    {
                        method,
                        params,
                        from: accounts[0],
                    },
                    function (err, result) {
                        if (err) return console.dir(err);
                        if (result.error) {
                            alert(result.error.message);
                        }
                        if (result.error) return console.error("ERROR", result);
                        console.log("TYPED SIGNED:" + JSON.stringify(result.result));


                    }
                );
        }
    </script>
    <button onclick="connect()">Connect</button>

    <button onclick="addEthereumChain()">ADD ETHEREUM CHAIN</button>
    <button onclick="signText()">SIGN TEXT</button>
    <button onclick="signStructuredExample()">SIGN STRUCTURED: example</button>
    <button onclick="signStructuredTailored()">SIGN STRUCTURED: tailored</button>
</body>

</html>